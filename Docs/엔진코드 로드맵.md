## TimeManager

```c++
TimeManager::Get().BeginFrame();

TimeManager::Get().ConsumeFixedSteps([&](float fixedDt)
{
    // 여기 안은 “예전 while(accumulator>=fixedDelta)” 내용
    PhysicsManager::Get()->PreSyncPhysicsWorld();
    PhysicsManager::Get()->PreApplyTransform();
    BehaviourManager::Get()->BroadCastBehaviourMessage("FixedUpdate");
    PhysicsManager::Get()->Simulate(fixedDt);
    PhysicsManager::Get()->ApplyTransform();
});

// 일반 업데이트 / 렌더
BehaviourManager::Get()->BroadCastBehaviourMessage("Update");
RenderManager::Get()->Render(TimeManager::Get().GetInterpolationAlpha());

```





## Object API 완성

- 엔진에서 관리되는 객체를 표현하는 최상위 클래스
- 리플렉션 기반과 힙 메모리에 관한 일관적인 처리를 위해 만듬
- 따라서 Object를 상속받는 모든 객체는 힙에서만 작동함 -> 스택 생성 코드 작동 안됨
- 그리고 절대 new,delete를 바로 쓸 수 없음, Object의 생성 파괴는 꼭 ObjectManager를 통해 이뤄져야함
- Object API -> Object, ObjectPtr, ObjectManager 로 크게 3가지 개념이 존재함
  - Object : 최상위 객체임, 상속 받는 순간 객체의 생명주기는 ObjectManager가 관리하게 됨
    - Object는 개념상 파괴된(해제된) 상태를 가질 수 있으며 Object::isDestroyed()로 그 여부를 파악할 수 있음

  - ObjectPtr< T > : Object객체는 직접 Raw Pointer (즉 Object*)로 쓸 수 없음 -> 주소 유효성을 파악할 수 없기 때문에 그럼
    - ObjectPtr.IsValid() 혹은 ObjectPtr != nullptr 같은 비교문으로 현재 포인터가 유효한 포인터인지 파악가능
    - 주소유효성 검증 후엔 (*ObjectPtr) 혹은 ObjectPtr-> 등의 연산자로 쉽게 접근 가능

  - ObjectManager : 할당되는 모든 Object를 관리하는 중앙관리자
    - 지연파괴 제공 -> 모든 Object는 Object::CreatePtr< T >()와 Object::Destroy()로 관리할 수 있음, 이 호출은 ObjectManager::CreatePtr< T >()와 ObjectManager::Destroy()를 감싸는 스크립팅 API함수임
    - Destroy()의 경우 메모리 해제를 즉시 시행하지 않고 개념상으로만 파괴해둔 뒤 게임프레임의 가장 끝에 모아둔 파괴 오브젝트를 일괄적으로 해제시킴
    - 또한 Destroy(Object, 5.0f)와 같이 예약을 걸어두어 시간이 지난 뒤 파괴 시킬 수 있음



## ~~Serializable Event~~

- 이름 뜻대로 직렬화 가능한 이벤트
- 델리게이트인데 저장/불러오기 가능함
- 함수는 RTTR을 이용한 런타임 이름찾기로, 호출자 참조는 GUID로 복원
- Fast Delegate 내부구현을 감쌈
- 람다는 절대 등록할 수 없음 (람다가 필요하면 기존 델리게이트를 사용할 것)




## Object Serializer (JSON + RTTR)

- RTTR 라이브러리를 사용한 고수준 API
  - 런타임 타입 문자열 조회 능력을 이용하여 일관성 있는 코드를 제공함
- 파이썬 분석기 제작 ( Header Tool )
  - 파이썬 코드로 빌드 파이프라인 초기 단계에 ScriptBehaviour(사용자 스크립트 코드)헤더를 전부 탐색해서 리플렉션에 필요한 코드를 자동 생성 시킴
  - 사용자가 직접 리플렉션을 구현하였다면 그 헤더는 스킵
    - (#define DONT_AUTOGEN_REFLECT_CODE 토큰 발견 시)
- 앞서 제작된 RTTR 코드를 전반적으로 이용하여 일관적인 META파일을 만듬
- 이 META파일과 리플렉션 코드는 에디터에서 IMGUI와 연동하여 사용할 예정임
- 추가적으로 Scene Rebuild에도 이 Serializer를 활용할 예정임
  - 시간이 더 된다면 Scene 객체를 만드는 팩토리 코드를 별도로 만들 수 있게 할 예정
  - 이 얘긴 즉슨 Player를 빌드할 때 Scene을 상속받은 객체코드를 새로 생성하고 Scene에서 요구하는 첫 초기화 코드 (하이어라키 복원)를 CPP 코드로 생성하여 Player DLL 내부에 넣어두고 마찬가지로 어떤 Scene이 플레이어에 들어가는지 알려주는 CPP 소스파일도 만들어서 main호출 할 때 이 Scene순서대로 로드시킬 예정

## GUID Helper + Scene Reload

- 씬 하이어라키를 저장 / 복원하는 작업이다
- 씬을 저장할 때 Serializer와 GUID Helper 이용하여 각 오브젝트 별 GUID를 생성 저장한다.
- 씬을 로드할 때는 다음 순번으로 진행한다.
  - Transform트리를 생각하지 않고 일단 json에 기록된 모든 GameObject를 생성한다.
    - 생성할 때는 게임오브젝트가 소지하던 컴포넌트는 같이 생성시켜준다(이건 바로 해당 게임오브젝트에 종속시킨다)
    - 또 생성하자 마자 그 즉시 Scene복구자에 생성된 테이블에 현재 생성된 객체의 GUID와 ObjectPtr< T >를 한쌍으로 넣어둔다
    - 단 그 컴포넌트가 다른 대상의 참조가 필요하면 그건 나둔다 (포인터타입, 참조타입은 비워둔채로 생성)
  - 이후 GameObject의 Transform을 복원하기 위해 모두 순회하여 GUID -> ObjectPtr< T >로 바꿔 부모와 자식을 차례차례 전부 이어준다.
  - 그리고 컴포넌트를 순회하며 참조가 필요한 멤버변수를 역시 GUID -> ObjectPtr< T >로 바꿔 전부 초기화 시켜준다.
- 그럼 씬 복원이 완료된다.



## ~~Resource Manager~~

- 리소스 로드를 실제 런타임(엔진이든 플레이어든)에 사용하기 위해 경로와 리소스 GUID를 묶은 리소스테이블 파일이 존재함

- 나중에 HeaderTool이 ScriptBehaviour(사용자 스크립트)의 소스를 전부 순회하면서 경로 문자열을 GUID로 전환함.

  



## Prefab

- 하이어라키의 구조(게임오브젝트 - 컴포넌트 - 리소스)를 직렬화한 데이터 = 하나의 파일단위
- 리소스 취급이며 prefab을 불러오면 GameObject로 전환됨
  - 씬 하이어라키에 올려둘 때 GameObject로 전환되지 않고 여전히 prefab으로 취급되는 그 유니티용 기능은 차후에 만드는 것이 좋을 듯



## AssimpConverter

- 모델 파일을 불러오면 Prefab으로 전환 시켜주는 기능
- 추가적으로 Mesh와 Texture, Material, AnimationClip 등을 나눠서 파일로 만들어줌 (Json 파일임)



## 렌더 큐

- Renderer들의 Draw는 D3D11 API를 직접 이용하지 않는다
  - Renderer를 상속받은 각 렌더러 컴포넌트가 Render에서 렌더큐에 보낼 메시지를 전송함
  - RenderManager의 Context에서 렌더큐는 전송받은 구조체를 RenderOrder로 정리하여 PriorityQueue에 올려놓는다 (자동 정렬)
  - RenderManager가 쌓인 렌더 큐를 정리한다 (Material 렌더 패스에서)
- Render Order가 Opaque, Transparent로 나뉘고 그 안에서 DepthOrder에 의해 순번이 정렬되기 때문에 자연스럽게 드로잉 가능
- 추가로 특정 렌더오더 ( 0 ~ 1000 : opaque, 1001 ~ 2000 : transparent ) 에서 세팅을 바꾸어 Set콜도 줄인다.



## 렌더 패스

- 기본적으로 아래와 같은 순서로 렌더패스가 구성됨
  - 포워드
    1. 쉐도우맵
    
    2. 스카이박스
    
    3. Opaque 및 Transparent ( 머터리얼 렌더패스 )
    
       - 문제가 있다면 현재 static, skinned에 대한 처리에 공통VS가 무조건 할당되어야 한다는 점임
         - 해결점을 찾음, VS는 모두 두 개를 만들 예정임 { static, skinned }
    
       - Material은 VS,PS,GS,HS,DS를 모두 한번에 담아서 처리
    
    4. Addtive 라이트 패스 ( 그림자 없는 포인트 라이트 + 스폿 라이트 )
    
    5. 파티클 패스
    
    6. 포스트 프로세싱
  - 디퍼드
    1. 쉐도우맵
    
    2. 스카이박스
    
    3. 지오메트리 패스
    
       - 이거때문에 많이 고민함
    
       - 엔진에서 제공하는 모든 VS와 PS는 Forward <-> Deffered 렌더러간 교환이 쉽도록 진입점을 forward와 deffered로 분리 구현하였음
    
    4. 라이트 패스  (Only Opaque - Material 패스)
    
       - Material API를 언급했지만 디퍼드 자체가 사실상 PBR을 위한 전용 패스으로 최적화될 가능성이 있음
    
       - 그래서 현재 라이트 패스는 PBR 단일 구현으로 진행됨
    
       - 추가로 블린퐁이나 스타일리쉬 패스를 추가하려면 지오메트리 패스와 Material API의 구조를 바꿔야 함
    
    5. 포워드 패스  (Only Transparent - Material 패스)
       - 여기는 기존에 포워드 패스 함수에서 SetFlag를 오로지 Transparent로만 줘서 처리할 듯
    
    6. 파티클 패스
    
    7. 포스트 프로세싱
- 언급한 것처럼 Material API는 패스 중간에서 실제 메쉬 표면을 이용한 드로잉을 중점을 둬 작성하였음



## ~~Vertex Shader Variant~~

- ILManager를 만든다
- GPU에 올릴 불변 정점 버퍼가 최대로 가질 수 있는 항목을 미리 정한다
  - pos
  - norm
  - tan
  - uv
  - boneIdx[4]
  - boneWeight[4]
- 모델을 임포팅하고 메쉬로 컨버팅할 때 메쉬는 아까 정해둔 항목 중 필요한 항목 만을 이용하여 파일 데이터(직렬화 가능한 구조)로 리소스화 시킴
- 나중에 실제 사용해야할 때 (프로그램 시작 시) 로드한 Mesh리소스는 불변 버퍼로 GPU 메모리에 올라감
- 이후 Renderer 클래스에서 Material에 할당된 셰이더 코드를 로드할 때 (특히 VS) 입력 레이아웃을 렌더러에 할당된 Mesh의 구조와 매칭시켜 만듬 (이미 있으면 참조만 가져옴) 
- 서로의 플래그가  [ VS ⊂ 메쉬 ] 인 경우 올바른 드로잉을 시도함
  - 아닌 경우 미리 정의된 셰이더로 두 가지 중에 하나를 출력
    - A : 정점데이터에 포지션 값을 가지고 있음 -> 표면전체를 Magenta { 1, 0, 1, 1 }로 메쉬 드로잉
    - B : 정점데이터에 포지션 값이 없음 -> 캐싱된 ERROR 모델 드로잉



==> 추가적인 정보, VS하나로 여러개의 IL을 만들 수 있다 캄

- 그렇단 얘기는 저기 로직을 한번 더 단축시켜서 IL조합을 줄일 수 있을 듯함



## Dynamic Material Property

- 머터리얼에서 쓰이는 VS,GS,PS 등의 버퍼 변수를 바깥으로 노출 시키는 기능, = GUI 및 스크립팅 API까지 노출시키는 역할을 해줌.

- 최종목표는 프로퍼티를 문자열로 찾아서 수정할 수 있게 처리하는 것임

```C++
{
    auto renderer = GetComponent<StaticMeshRenderer>();
    ObjectPtr<Material> mat = renderer->GetMaterial(); // 0번째 머터리얼을 반환
    mat->SetProperty("_Color", XMFLOAT4{1,0,0,1} );  // Material::SetProperty<T>(std::string,T data)에서 T가 자동 평가됨
    //혹은 mat->SetColor("_Color",{1,0,0,1});
    
    auto debugPrintText1 = std::to_string(mat->GetProperty<FLOAT>("_Thickness")); 
	//혹은 mat->GetFloat("_Thickness");
}
```



## 씬 트랜스폼 피킹

![image.png](Images/image (5).png)

- R32_UINT (0 ~ 4,294,967,296) 채널
- 빨간색이 진할 수록 큰 ID값
- Editor 전용 렌더패스
- 이 텍스쳐를 사용해서 피킹을 빠르게 구현

→ 뎁스 테스트를 키고 Scene Cam과 Viewport설정을 이용해서 Renderer를 빠르게 돌아 찍어내기

= 찍을 때는 꼭 RendererID(RenderManager 내부의 배열의 IDX)를 이용해서 찍을 것
