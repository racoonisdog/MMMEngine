## BVH2 만들기

- 이전 코드는 BVH에 사용되는 BBOX의 생명주기가 프로그램 시작 <-> 프로그램 종료까지 였다
  - = BBOX의 참조는 항상 유효하다, 심지어 정적이기 때문에 프로그램 시작 시 한번의 초기화로 모든 것이 잘 동작함
- 현재 코드는 BVH에 사용되는 BBOX의 생명주기가 불안정하다. 언제 삭제될 지 모른다
  - = BBOX의 참조는 유효할 수도 아닐 수도 있다.
  - 유효하지 않은 참조가 걸리면 위험하기 때문에 매 프레임 마다 참조가 있는 BBOX가 사라질 때 BVH의 트리를 한 번 업데이트 해줘야 한다.
  - 또한 신규 BBOX로 인해 참조가 추가될 때에도 BVH트리가 업데이트 되어야 한다.
  - 앞 선 규칙을 지켜서 Refit()과 Insert() Remove()를 모두 구현하여 동적 BVH 트리를 완성해야 함
  - 현재는 과제 코드이기 때문에 별도의 Object 없이 Transform을 참조하는 것으로 결정함
  - Transform에는 IsMatrixDirty()라는 항목이 존재하기 때문에 (심지어 parent-child 형태의 하이어라키 구조도 가지고 있음 ) 매 BVH체킹에서 해당 구문으로 BBOX의 이동이 필요한 친구들을 전부 마킹해서 처리할 수 있도록 해주는 것이 포인트



## 에디터용 Reflection 구현

- RTTR 라이브러리를 사용한 고수준 API 작성
  - 런타임 타입 문자열 조회 능력을 이용하여 일관성 있는 코드를 제공함



## Object API 완성

- 모든 객체를 표현하는 최상위 클래스
- 힙 메모리에 관해 일관적인 처리를 위해 만듬
- 현재 댕글링 포인터 방지를 위한 방법을 구상하고 있음



### | 댕글링 포인터 대안 |

#### > A안 

-  Object Handle을 구현하고 사용자가 Handle을 이용하게 하도록 강제



#### > B안

- C++내부의 RAII 구현을 최대한 이용하기 
  - 스마트 포인터를 적절히 이용하여 ObjectManager를 만들고 Weak 저장 Shared 배출 구조의 테이블을 구성해서 더 이상 참조하지 않는 Object는 자동 해제되게 보장 



#### > 공통 구현

- OnDestroy() 이벤트 호출 시간에 무조건 Object로 구현한 Component가 살아있어야 함으로 ObjectManager나 어떤 레지스트리도 괜찮으니 지연파괴를 구현할 것, 그래서 Object를 파괴할 때 개념상으로만 파괴시키고 실제 로직에서는 프레임 처리 맨 마지막에 파괴처리할 것



## Prefab

- 하이어라키의 구조(게임오브젝트 - 컴포넌트 - 리소스)를 직렬화한 데이터 = 하나의 파일단위
- 리소스 취급이며 prefab을 불러오면 GameObject로 전환됨
  - 전환되지 않고 여전히 prefab으로 취급하는 그 유니티용 기능은 차후에 만드는 것이 좋을 듯
- 모델 파일을 불러오면 Prefab으로 전환 시켜주는데, 컴포넌트에 들어가는 리소스로서 부착되는 형태이면 자동으로 리소스화 시켜줌 (Asset/Resource/[ Mesh, Texture , Material, AnimationClip ]에 만들어 줌)



## Resource Manager + GUID Helper

- 리소스는 GUID가 존재한다, 이것을 실제 런타임(엔진이든 플레이어든)에 사용하기 위해 경로와 리소스 GUID를 묶은 리소스테이블 파일이 존재함
  - Concrete 엔진에서 어떻게 만드는지 체크해둘 것



## 렌더 패스





## Vertex Shader Variant

- ILManager를 만든다
- GPU에 올릴 불변 정점 버퍼가 최대로 가질 수 있는 항목을 미리 정한다
  - pos
  - norm
  - tan
  - uv
  - boneIdx[4]
  - boneWeight[4]
- 모델을 임포팅하고 메쉬로 컨버팅할 때 메쉬는 아까 정해둔 항목 중 필요한 항목 만을 이용하여 파일 데이터(직렬화 가능한 구조)로 리소스화 시킴
- 나중에 실제 사용해야할 때 (프로그램 시작 시) 로드한 Mesh리소스는 불변 버퍼로 GPU 메모리에 올라감
- 이후 Renderer 클래스에서 Material에 할당된 셰이더 코드를 로드할 때 (특히 VS) 입력 레이아웃을 렌더러에 할당된 Mesh의 구조와 매칭시켜 만듬 (이미 있으면 참조만 가져옴) 
- 서로의 플래그가  [ VS ⊂ 메쉬 ] 인 경우 올바른 드로잉을 시도함
  - 아닌 경우 미리 정의된 셰이더로 두 가지 중에 하나를 출력
    - A : 정점데이터에 포지션 값을 가지고 있음 -> 표면전체를 Magenta { 1, 0, 1, 1 }로 메쉬 드로잉
    - B : 정점데이터에 포지션 값이 없음 -> 캐싱된 ERROR 모델 드로잉



## Dynamic Material Property

ShaderManager에서 Shader를 통합 관리하게 만들고 Shader Property로 구분되는 cbuffer를 실제 shader를 사용할 때 GPU에 만들어 보관해둔 뒤에 Material Property가 참조중인 셰이더를 모두 순회하면서 각 셰이더 스테이지 별로 필요한 ShaderProperty를 자신만의 MaterialProperty(CPU 데이터)로 바꿔 배열로 소지하고 있다가 Draw시에 ShaderBind



메쉬렌더러 <- 다양한 머터리얼을 넣을 수 있음, 머터리얼 마다 렌더링을 검